{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"The Assembly Chronicles \u2013 PIC","text":"<p>Gu\u00eda t\u00e9cnica de referencia para microcontroladores PIC18F47Q10 (y PIC18F57Q43)</p> <p>Documentaci\u00f3n orientada a estudiantes de Ingenier\u00eda Electr\u00f3nica, Mecatr\u00f3nica y Biom\u00e9dica \u2014 basada en el curso Microcontroladores (1AEL0256) de la Universidad Peruana de Ciencias Aplicadas.</p> <p>Ver en GitHub  Empezar a leer </p>"},{"location":"#secciones","title":"Secciones","text":""},{"location":"#teoria","title":"Teor\u00eda","text":"<p>Si quieres usar el Q10, debes entender los fundamentos de su arquitectura y de sus m\u00f3dulos (temporizadores, interrupciones, CPP, I2C, entre otros). Los temas se explican con diagramas de bloques, tablas de registros y f\u00f3rmulas de c\u00e1lculo.</p> <p> Ir a Teor\u00eda</p>"},{"location":"#proyectos","title":"Proyectos","text":"<p>Tu IA de confianza agradecer\u00e1 que le pases ejemplos pr\u00e1cticos del desarrollo de proyectos paso a paso en Assembly y C para tus laboratorios. Adem\u00e1s, encontrar\u00e1s los diagramas de flujo, esquemas de conexi\u00f3n y c\u00f3digo fuente de cada proyecto.</p> <p> Ir a Proyectos</p>"},{"location":"#recursos","title":"Recursos","text":"<p>Si deseas usar un m\u00f3dulo, el datasheet es tu mejor amigo, pero tiene la informaci\u00f3n muy dispersa. Para casos sencillos, si no quieres visitar al datasheet ni la teor\u00eda, en esta secci\u00f3n encontrar\u00e1s res\u00famenes de los m\u00f3dulos m\u00e1s importantes, con sus f\u00f3rmulas de c\u00e1lculo, tablas de registros y ejemplos de configuraci\u00f3n. </p> <p> Ir a Recursos</p>"},{"location":"#stack-tecnologico","title":"Stack tecnol\u00f3gico","text":"Herramienta Uso MPLAB X IDE Entorno de desarrollo integrado XC8 Compilador de C y Assembly PIC18F47Q10 Curiosity Nano Placa de desarrollo y depuraci\u00f3n. <p>Se recomienda complementar la informaci\u00f3n aqu\u00ed presentada con la documentaci\u00f3n oficial de Microchip.</p>"},{"location":"proyectos/","title":"Proyectos","text":"<p>Secci\u00f3n dedicada a proyectos pr\u00e1cticos con los microcontroladores PIC18F57Q43 y PIC18F47Q10. Cada proyecto incluye c\u00f3digo fuente, esquem\u00e1ticos y explicaciones paso a paso.</p> <p>En construcci\u00f3n</p> <p>Los proyectos se ir\u00e1n agregando conforme avance el curso. Algunos proyectos planeados:</p> <ul> <li> Blink LED \u2014 primer programa en Assembly</li> <li> Lectura de bot\u00f3n con antirrebote</li> <li> Display 7 segmentos multiplexado</li> <li> Temporizador con TMR0</li> <li> Interrupci\u00f3n externa con INT</li> <li> PWM para control de brillo</li> <li> Comunicaci\u00f3n EUSART</li> </ul>"},{"location":"proyectos/#estructura-de-cada-proyecto","title":"Estructura de cada proyecto","text":"<p>Cada proyecto seguir\u00e1 esta estructura est\u00e1ndar:</p> <pre><code>proyectos/\n\u2514\u2500\u2500 nombre-del-proyecto/\n    \u251c\u2500\u2500 README.md          # Descripci\u00f3n y objetivos\n    \u251c\u2500\u2500 src/               # C\u00f3digo fuente (.asm / .c)\n    \u251c\u2500\u2500 sim/               # Archivos de simulaci\u00f3n\n    \u2514\u2500\u2500 docs/              # Diagramas y fotos\n</code></pre> <p>\u00bfC\u00f3mo compilar?</p> <p>Todos los proyectos est\u00e1n dise\u00f1ados para compilarse con MPLAB X IDE y PIC AS Assembler. Consulta la gu\u00eda de configuraci\u00f3n del entorno en la secci\u00f3n de Recursos.</p>"},{"location":"recursos/","title":"Recursos","text":"<p>A continuaci\u00f3n, encontrar\u00e1s res\u00famenes de los m\u00f3dulos m\u00e1s importantes, con sus f\u00f3rmulas de c\u00e1lculo, tablas de registros y ejemplos de configuraci\u00f3n. Adem\u00e1s, se listan los datasheets oficiales de Microchip, herramientas de desarrollo y referencias del curso.</p> M\u00f3dulo Descripci\u00f3n CCP M\u00f3dulo de captura, comparaci\u00f3n y PWM TMR0 Temporizador Timer 0 en modo 8 y 16 bits"},{"location":"recursos/#librerias-del-curso","title":"Librer\u00edas del curso","text":"<p>Las librer\u00edas usadas en el curso fueron originalmente desarrolladas por el Prof. Sergio Salas y posteriormente modificadas por Kalun Jose Lau Gan. Puedes encontrar las librer\u00edas originales en el repositorio de Kalun.</p> <p>Librer\u00edas modificadas</p> <p>Algunas librer\u00edas han sido modificadas para mejorar su documentaci\u00f3n y corregir inconvenientes. Te recomiendo usar las versiones incluidas en este repositorio.</p>"},{"location":"recursos/#librerias-disponibles","title":"Librer\u00edas disponibles","text":"Librer\u00eda Descripci\u00f3n Repositorio LCD1602 Control de pantalla LCD 16x2 (versi\u00f3n modificada)  Ver documentaci\u00f3n Otras librer\u00edas Modulos adicionales del curso  Repositorio de Kalun <p>Recomendaci\u00f3n</p> <p>Por ahora, solo la librer\u00eda LCD ha sido modificada y mejorada. Para las dem\u00e1s librer\u00edas, puedes usar las versiones del repositorio de Kalun.</p>"},{"location":"recursos/#documentos-oficiales","title":"Documentos oficiales","text":"Documento Enlace PIC18F47Q10 Family Datasheet Microchip Curiosity Nano PIC18F47Q10 User Guide Microchip PIC18F57Q43 Family Datasheet Microchip Curiosity Nano PIC18F57Q43 User Guide Microchip"},{"location":"recursos/#herramientas-de-desarrollo","title":"Herramientas de desarrollo","text":"Herramienta Descripci\u00f3n Enlace MPLAB X IDE Entorno de desarrollo integrado Descargar Proteus Simulador de circuitos Labcenter"},{"location":"recursos/#referencias-del-curso","title":"Referencias del curso","text":"<ul> <li> Material base del curso \u2014 Ing. Kalun Jose Lau Gan</li> <li> PIC18F57Q43 Instruction Set</li> </ul> <p>Datasheets locales</p> <p>Las im\u00e1genes de datasheets utilizadas en esta documentaci\u00f3n se encuentran en la carpeta <code>assets/images/</code> del sitio. Para acceder a los documentos PDF completos, consulta los enlaces de Microchip listados arriba.</p>"},{"location":"recursos/ccp_pwm/","title":"CCP \u2013 Gu\u00eda R\u00e1pida (Modo PWM)","text":"<p>Para m\u00e1s detalles sobre el m\u00f3dulo CCP, su configuraci\u00f3n y funcionamiento, consultar la gu\u00eda completa.</p>","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#calculos-previos","title":"C\u00e1lculos Previos","text":"","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#periodo-pwm","title":"Periodo PWM","text":"\\[TxPR = \\frac{T_{PWM} \\times F_{osc}}{4 \\times TMRx\\ Prescaler} - 1\\] F\u00f3rmula de verificaci\u00f3n<sup>7</sup> \\[T_{PWM} = \\frac{4 \\times (TxPR+1) \\times TMRx\\ Prescaler}{F_{osc}}\\] <p>Fuente de reloj</p> <p>Es menester que la fuente de reloj del timer sea \\(\\frac{F_{osc}}{4}\\) para el correcto funcionamiento del m\u00f3dulo CCP. El PostScaler no afecta el periodo PWM.</p>","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#duty-cycle-tiempo-en-alto","title":"Duty Cycle (Tiempo en alto)","text":"\\[\\text{CCPRx value} = \\frac{T_{ON} \\times F_{osc}}{TMRx\\text{ Prescaler}}\\] F\u00f3rmula de verificaci\u00f3n<sup>8</sup> \\[T_{ON} = CCPRx\\text{ value} \\times \\frac{TMRx\\text{ Prescaler}}{F_{osc}}\\] <ul> <li>Si <code>FMT = 0</code> (derecha): <code>CCPRx value = CCPRxH[1:0]:CCPRxL</code></li> <li>Si <code>FMT = 1</code> (izquierda): <code>CCPRx value = CCPRxH:CCPRxL[7:6]</code></li> </ul>","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#registros-a-usar","title":"Registros a usar","text":"Registro Funci\u00f3n Banco <code>CCPTMRS</code><sup>1</sup> Selecci\u00f3n del timer asociado al CCPx Access <code>RxyPPS</code><sup>2</sup> Asigna pin de salida al m\u00f3dulo CCPx <code>0x0E</code> <code>TRISx</code> Direcci\u00f3n del pin (entrada/salida) Access <code>TxPR</code> Cuenta m\u00e1xima del timer \u2192 define periodo PWM Access <code>CCPxCON</code><sup>3</sup> Control del CCP: habilitar (<code>EN</code>), modo (<code>MODE</code>), formato (<code>FMT</code>) Access <code>CCPRxH:L</code> Valor de 10 bits que define el duty cycle Access <code>TxCLKCON</code> Fuente de reloj del timer (<code>TxCLKCON=1</code> \u2192 \\(F_{osc}/4\\)) Access <code>TxCON</code><sup>5</sup> Control del timer: habilitar (<code>ON</code>), prescaler (<code>CKPS</code>) Access <code>PIR4</code><sup>4</sup> Banderas de interrupci\u00f3n TMR2/4/6 (<code>TMR2IF</code> bit 1) <code>0x0E</code>","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#ccptmrs-bits-cxtsel","title":"CCPTMRS: Bits CxTSEL","text":"Bits 3:2 Bits 1:0 C2TSEL[1:0] C1TSEL[1:0] <ul> <li>Seleccionar TMR2 (<code>CxTSEL = 00</code>), TMR4 (<code>CxTSEL = 10</code>) o TMR6 (<code>CxTSEL = 11</code>)</li> </ul>","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#pps-codigos-de-salida-ccp","title":"PPS: C\u00f3digos de salida CCP","text":"RxyPPS M\u00f3dulo Puertos destino 0x05 CCP1 RB, RC 0x06 CCP2 RB, RC","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#ccpxcon","title":"CCPxCON","text":"Bit 7 Bit 5 Bit 4 Bits 3:0 EN OUT (RO) FMT MODE[3:0] <ul> <li>Modo PWM: <code>MODE = 11xx</code></li> <li><code>FMT = 1</code>: justificado a la izquierda / <code>FMT = 0</code>: derecha</li> </ul>","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#txcon","title":"TxCON","text":"Bit 7 Bits 6:4 Bits 3:0 ON CKPS[2:0] OUTPS[3:0] <ul> <li><code>ON = 1</code>: habilitar timer</li> <li><code>CKPS</code>: prescaler (000 = 1:1, 001 = 1:2, \u2026, 111 = 1:128)</li> </ul>","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#pir4-banderas-tmr246","title":"PIR4: Banderas TMR2/4/6","text":"Bit 5 Bit 3 Bit 1 TMR6IF TMR4IF TMR2IF","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#configuracion-rapida","title":"Configuraci\u00f3n r\u00e1pida","text":"<p>No evita \"pulsos basura\" durante la configuraci\u00f3n.</p> <ol> <li>Seleccionar timer (TMR2/4/6) con <code>CCPTMRS</code><sup>1</sup>.</li> <li>Asignar v\u00eda PPS un pin al CCP1 (<code>RxyPPS=5</code>) o al CCP2 (<code>RxyPPS=6</code>) <sup>2</sup>.</li> <li>Configurar el pin como salida (<code>TRISxbits.TRISxy = 0</code>).</li> <li>Cargar el periodo calculado en <code>TxPR</code>.</li> <li>Configurar <code>CCPxCON</code>: modo PWM + formato (<code>EN</code>, <code>MODE</code>, <code>FMT</code>)<sup>3</sup>.</li> <li>Cargar duty cycle calculado (10 bits) en <code>CCPRxH:L</code>.</li> <li>Seleccionar reloj del timer: <code>TxCLKCON = 1</code> (\\(\\frac{F_{osc}}{4}\\)).</li> <li>Configurar prescaler y habilitar timer: <code>TxCON</code> (<code>ON = 1</code>)<sup>5</sup>.</li> </ol>","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#configuracion-segura","title":"Configuraci\u00f3n segura","text":"<p>Evita \"pulsos basura\" configurando el pin como entrada hasta que el timer est\u00e9 listo<sup>6</sup>.</p> <ol> <li>Seleccionar timer (TMR2/4/6) con <code>CCPTMRS</code><sup>1</sup>.</li> <li>Asignar v\u00eda PPS un pin al CCP1 (<code>RxyPPS=5</code>) o al CCP2 (<code>RxyPPS=6</code>) <sup>2</sup>.</li> <li>Configurar el pin como entrada (<code>TRISxbits.TRISxy = 1</code>).</li> <li>Cargar el periodo calculado en <code>TxPR</code>.</li> <li>Configurar <code>CCPxCON</code>: modo PWM + formato (<code>EN</code>, <code>MODE</code>, <code>FMT</code>)<sup>3</sup>.</li> <li>Cargar duty cycle calculado (10 bits) en <code>CCPRxH:L</code>.</li> <li>Bajar bandera <code>TMRxIF</code> en <code>PIR4</code><sup>4</sup>.</li> <li>Seleccionar reloj del timer: <code>TxCLKCON = 1</code> (\\(\\frac{F_{osc}}{4}\\)).</li> <li>Configurar prescaler y habilitar timer: <code>TxCON</code> (<code>ON = 1</code>)<sup>5</sup>.</li> <li>Esperar a que <code>TMRxIF == 1</code>.</li> <li>Habilitar salida del pin (<code>TRISxbits.TRISxy = 0</code>).</li> </ol>","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/ccp_pwm/#referencias","title":"Referencias","text":"<ol> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 22.6.4, \"CCPTMRS\". Ver PDF (P\u00e1g. 359).\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 18.2, \"PPS Outputs\". Ver PDF (P\u00e1g. 287).\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 22.6.1, \"CCPxCON\". Ver PDF (P\u00e1g. 356).\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.13.6, \"PIR4\". Ver PDF (P\u00e1g. 203).\u00a0\u21a9\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 21.9.3, \"TxCON\". Ver PDF (P\u00e1g. 341).\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 22.4.2, \"Setup for PWM Operation\". Ver PDF (P\u00e1g. 351).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 22.4.4, \"PWM Period\". Ver PDF (P\u00e1g. 352).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 22.4.5, \"PWM Duty Cycle\". Ver PDF (P\u00e1g. 353).\u00a0\u21a9</p> </li> </ol>","tags":["CCP","PWM","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/tmr0/","title":"TMR0 \u2013 Gu\u00eda R\u00e1pida","text":"<p>Para m\u00e1s detalles sobre el m\u00f3dulo TMR0, su configuraci\u00f3n y funcionamiento, consultar la gu\u00eda completa.</p>","tags":["TMR0","Timer0","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/tmr0/#calculos-previos","title":"C\u00e1lculos Previos","text":"","tags":["TMR0","Timer0","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/tmr0/#duracion-del-temporizador","title":"Duraci\u00f3n del temporizador","text":"\\[ \\text{Duracion} = \\frac{\\text{PreScaler} \\times \\text{Num. Cuentas} \\times \\text{PostScaler}}{F_{\\text{TMR0}}} \\]","tags":["TMR0","Timer0","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/tmr0/#modo-8-bits","title":"Modo 8 bits","text":"\\[ \\mathtt{TMR0H} = \\frac {\\text{Duracion} \\times F_{\\text{TMR0}}} {\\text{PreScaler} \\times \\text{PostScaler}} \\leq 255 \\]","tags":["TMR0","Timer0","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/tmr0/#modo-16-bits","title":"Modo 16 bits","text":"\\[ \\mathtt{TMR0H:L} = 65536 - \\frac {\\text{Duracion} \\times F_{\\text{TMR0}}} {\\text{PreScaler} \\times \\text{PostScaler}} \\geq 0\\] <p>Orden de lectura / escritura (16 bits)</p> <ul> <li>Leer: primero <code>TMR0L</code>, luego <code>TMR0H</code>.</li> <li>Escribir: primero <code>TMR0H</code>, luego <code>TMR0L</code>.</li> </ul>","tags":["TMR0","Timer0","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/tmr0/#registros-a-usar","title":"Registros a usar","text":"Registro Funci\u00f3n Banco <code>T0CON0</code> Control: habilitar (<code>T0EN</code>), modo (<code>T016BIT</code>), postscaler (<code>T0OUTPS</code>) Access <code>T0CON1</code> Fuente de reloj (<code>T0CS</code>), sincron\u00eda (<code>T0ASYNC</code>), prescaler (<code>T0CKPS</code>) Access <code>TMR0H</code> Valor de comparaci\u00f3n (8 bits) / byte alto del contador (16 bits) Access <code>TMR0L</code> Contador (8 bits) / byte bajo del contador (16 bits) Access <code>PIR0</code> Bandera de interrupci\u00f3n <code>TMR0IF</code> (bit 5) <code>0x0E</code> <code>PIE0</code> Habilitaci\u00f3n de interrupci\u00f3n <code>TMR0IE</code> (bit 5) <code>0x0E</code> <code>IPR0</code> Prioridad de interrupci\u00f3n <code>TMR0IP</code> (bit 5) <code>0x0E</code> <code>RxyPPS</code> Salida PPS de <code>T0_out</code> (<code>0x13</code>). Solo RB y RC. Divide \u00f72 la frecuencia <code>0x0E</code>","tags":["TMR0","Timer0","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/tmr0/#t0con0","title":"T0CON0","text":"Bit 7 Bit 5 Bit 4 Bits 3:0 T0EN T0OUT (RO) T016BIT T0OUTPS[3:0] <ul> <li><code>T0EN = 1</code>: habilitar timer.</li> <li><code>T016BIT = 1</code>: modo 16 bits / <code>T016BIT = 0</code>: modo 8 bits.</li> <li><code>T0OUT</code>: salida <code>T0_out</code>, se alterna al ocurrir cada interrupci\u00f3n.</li> <li><code>T0OUTPS</code>: postscaler \u2014 cuenta \\((\\text{valor}+1)\\) eventos antes de levantar <code>TMR0IF</code>.</li> </ul>","tags":["TMR0","Timer0","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/tmr0/#t0con1","title":"T0CON1","text":"Bits 7:5 Bit 4 Bits 3:0 T0CS[2:0] T0ASYNC T0CKPS[3:0] <ul> <li><code>T0CS[2:0]</code>: Selecciona la fuente de reloj.  </li> <li><code>T0ASYNC = 1</code>: fuente as\u00edncrona con el reloj del sistema.</li> <li><code>T0CKPS[3:0]</code>: prescaler \u2014 divisor de frecuencia de \\(2^{(\\text{valor})}\\).</li> </ul> T0CS[2:0]: Fuentes de reloj T0CS[2:0] Fuente 000 T0CKIPPS 001 \\(\\overline{\\text{T0CKIPPS}}\\) 010 Fosc/4 011 HFINTOSC 100 LFINTOSC 101 MFINTOSC 500 kHz 110 SOSC 111 CLC1_OUT","tags":["TMR0","Timer0","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/tmr0/#configuracion-basica","title":"Configuraci\u00f3n b\u00e1sica","text":"<ol> <li>Configurar <code>T0CON1</code>: fuente de reloj (<code>T0CS</code>), prescaler (<code>T0CKPS</code>) y sincron\u00eda (<code>T0ASYNC</code>).</li> <li>Configurar <code>T0CON0</code>: modo (<code>T016BIT</code>), postscaler (<code>T0OUTPS</code>).</li> <li>8 bits: escribir en <code>TMR0H</code> el valor \\(\\text{cuenta m\u00e1xima} + 1\\).</li> <li>16 bits: (opcional) precargar <code>TMR0H:TMR0L</code> con <code>EN = 0</code>.</li> <li>Habilitar el timer: <code>T0CON0.T0EN = 1</code>.</li> </ol>","tags":["TMR0","Timer0","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"recursos/tmr0/#configuraciones-opcionales","title":"Configuraciones opcionales","text":"<ol> <li>Interrupci\u00f3n: bajar <code>PIR0.TMR0IF</code>, habilitar <code>PIE0.TMR0IE</code> y (opscional) configurar <code>IPR0.TMR0IP</code> para la prioridad. No olvidar tener configurado el INTCON para habilitar las interrupciones.</li> <li>PPS: escribir <code>0x13</code> en <code>RxyPPS</code> (solo RB y RC). Divide \u00f72 la frecuencia de <code>T0_out</code>.</li> </ol>","tags":["TMR0","Timer0","gu\u00eda r\u00e1pida","PIC18F47Q10"]},{"location":"teoria/","title":"Teor\u00eda","text":""},{"location":"teoria/#contenido-disponible","title":"Contenido disponible","text":"Tema Descripci\u00f3n Introducci\u00f3n Definici\u00f3n de microcontrolador y uso b\u00e1sico del MPLAB X IDE Arquitectura de un PIC18F C\u00f3mo se relaciona el \u00b5C con sus registros, memoria y perif\u00e9ricos Temporizadores TMR0/1/2 \u2014 registros, f\u00f3rmulas y configuraci\u00f3n Interrupciones Vectores, prioridades, banderas y dise\u00f1o de ISR CCP Configuraci\u00f3n del m\u00f3dulo CCP en modo PWM"},{"location":"teoria/#temas-por-agregar","title":"Temas por agregar","text":"En construcci\u00f3n <p>Los siguientes temas se ir\u00e1n incorporando progresivamente:</p> <ul> <li> Osciladores (configuraci\u00f3n del reloj)</li> <li> Interrupciones</li> <li> Celdas l\u00f3gica configurable</li> <li> Convertidor anal\u00f3gico-digital (ADC\u00b2)</li> </ul>"},{"location":"teoria/arquitectura/","title":"Arquitectura de un PIC18F","text":"","tags":["PIC"]},{"location":"teoria/arquitectura/#la-arquitectura-harvard","title":"La arquitectura Harvard","text":"<p> Los \u00b5C PIC siguen la arquitectura Harvard. Esto significa que tienen buses separados para instrucciones y datos, lo que permite acceder a ambos simult\u00e1neamente. </p> <p>En el diagrama de bloques del Q10 encontrar\u00e1s el bus de datos (en rojo) y el de instruccione (en verde) separados. Por esto, se dice que es una arquitectura Harvard.</p> Diagrama de bloques de la familia PIC18F27/47Q10 <sup>1</sup> <p>Lo mismo pasa con el Q43, pero no te voy a colorear la diferencia. Lo que s\u00ed, es importante destacar las aparentes diferencias que en realidad no lo son. Por ejemplo, el bus de datos del Q10 va conectado a sus perif\u00e9ricos de entrada/salida (PORT) y dem\u00e1s m\u00f3dulos, mientras que el del Q43, a pesar de tambi\u00e9n hacerlo, lo obvia en su diagrama. </p> Diagrama de bloques de la familia PIC18F27/47/57Q43 <sup>2</sup>","tags":["PIC"]},{"location":"teoria/arquitectura/#memoria-y-registros","title":"Memoria y registros","text":"<p>Dado que el Q10 y Q43 son de 8 bits, su bus de datos es de 8 bits, lo que implica que sus registros y memoria tambi\u00e9n son de 8 bits (1 byte \u2053 hexadecimal de 2 d\u00edgitos). A continuaci\u00f3n, se detalla la divisi\u00f3n de memoria de ambos \u00b5C:</p> Distribuci\u00f3n de memoria en los Q43 y Q10 Tipo de Memoria Tecnolog\u00eda Uso Principal 18F57Q43 18F47Q10 Program Flash No Vol\u00e1til Almacenamiento del c\u00f3digo (instrucciones) 128 KB 128 KB Data SRAM Vol\u00e1til Variables din\u00e1micas y Software Stack 8 KB \u20533,5 KB Data EEPROM No Vol\u00e1til Almacenamiento de datos persistentes 1 KB 1 KB <p>Uso del EEPROM</p> <p>A pesar de su encanto, no veremos c\u00f3mo manejar la EEPROM en este curso. Y, a fines pr\u00e1cticos, se entender\u00e1 como un perif\u00e9rico de almacenamiento.</p>","tags":["PIC"]},{"location":"teoria/arquitectura/#memoria-de-programa","title":"Memoria de programa","text":"<p>La memoria de programa es donde se almacenan las intrucciones que componen el programa que ejecuta el  \u00b5C. Siempre es no vol\u00e1til (no se borra al apagar el dispositivo) y, para el caso del Q10 y Q43 es tipo Flash.</p> <p>En la tabla anterior se muestra que ambos \u00b5C tienen 64 kW (1 word \\(=\\) 2 bytes) de memoria de programa, que puede guardar hasta \\(65 536 = 1 024\\times 64\\) instrucciones. Esto se debe a que, las instrucciones ocupan, por lo general, una palabra de la memoria de programa. Para el Q10, las excepciones son las instrucciones <code>MOVFF</code>, <code>GOTO</code>, <code>CALL</code> y <code>LFSR</code>, que ocupan dos palabras. En adici\u00f3n de esas intrucciones, el Q43 tiene la instrucci\u00f3n <code>MOVFFL</code> que ocupa tres palabras.</p> <p>En el Q10, la memoria de programa abarca el rango de direcciones desde <code>00 0000h</code> hasta <code>01 FFFFh</code>. Y, como se muestra en la tabla siguiente, tambi\u00e9n incluye los vectores de interrupci\u00f3n y el vector de reset. El vector de reset es la direcci\u00f3n a la que el \u00b5C salta para iniciar la ejecuci\u00f3n del programa despu\u00e9s de un reinicio. En la mayor\u00eda de los casos (el Q10 y Q43 inclusive), esta direcci\u00f3n es <code>00 0000h</code>. Por esto, es com\u00fan colocar una instrucci\u00f3n de salto en <code>00 0000h</code> que redirija a la direcci\u00f3n donde realmente se encuentra el programa. Pero, \u00bfd\u00f3nde deber\u00eda empezar el programa? Al menos, no debe de interponerse con los vectores de interrupci\u00f3n. Por lo tanto, el programa del Q10 puede empezar a partir de <code>00 001Ah</code> o m\u00e1s all\u00e1. En pic-as (ensamblador), esto se traduce en: <pre><code>  ORG 00h ; La siguiente instrucci\u00f3n estar\u00e1 en el vector de reset\n  bra 1Ah ; Salto a donde empieza el programa\n</code></pre> O sea, que en la direcci\u00f3n <code>00h</code> (vector de reset) se coloca la instrucci\u00f3n de salto (<code>bra</code>) que redirige a la direcci\u00f3n <code>1Ah</code>, donde realmente empieza el programa. Aunque, por razones de estilo, algunos profesores prefieren colocar el programa a partir de <code>00 0020h</code> o <code>00 0100h</code>. Adem\u00e1s, se puede usar una etiqueta para marcar el inicio del programa, como <code>inicio</code>, y luego usar esa etiqueta en la instrucci\u00f3n de salto: <pre><code>  ORG 00h ; La siguiente instrucci\u00f3n estar\u00e1 en el vector de reset\n  bra main ; Salto a donde empieza el programa\n  ORG 1Ah ; La siguiente instrucci\u00f3n estar\u00e1 en la direcci\u00f3n 1Ah \nmain:\n  ; Aqu\u00ed va el c\u00f3digo del programa\n</code></pre></p> Mapa de memoria de programa y datos del Q10 <sup>3</sup> Rango de Direcciones Secci\u00f3n de Memoria Detalles / Tama\u00f1o <code>00 0000h</code> Reset Vector Inicio del programa <code>00 0008h</code> Interrupt Vector High Interrupciones de Alta Prioridad <code>00 0018h</code> Interrupt Vector Low Interrupciones de Baja Prioridad <code>00 001Ah</code> - <code>01 FFFFh</code> Program Flash Memory 64 KW (Espacio de c\u00f3digo) <code>30 0000h</code> - <code>30 000Bh</code> Configuration Words 6 Words (Configuraci\u00f3n de Fusibles) <code>31 0000h</code> - <code>31 00FFh</code> Data EEPROM 1024 Bytes (Datos No Vol\u00e1tiles)","tags":["PIC"]},{"location":"teoria/arquitectura/#referencias","title":"Referencias","text":"<ol> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 2.3, \"Details on Individual Family Members\". Ver PDF (P\u00e1g. 18).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2021). PIC18F27/47/57Q43 Microcontroller Data Sheet. Secci\u00f3n 7, \"PIC18 CPU\". Ver PDF (P\u00e1g. 28).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 11.1, \"Program Memory Organization\". Ver PDF (P\u00e1g. 108).\u00a0\u21a9</p> </li> </ol>","tags":["PIC"]},{"location":"teoria/ccp/","title":"Captura/Comparaci\u00f3n/PWM (CCP)","text":"<p>El m\u00f3dulo CCP (Capture/Compare/PWM) es un perif\u00e9rico vers\u00e1til que se encuentra en los \u00b5C PIC18F, incluyendo el Q10 (CCP1/2) y Q43 (CCP1/2/3).  El nombre se debe a los tres modos en los que opera. Por ahora, nos enfocaremos en el modo PWM (pulse width modulation). </p>"},{"location":"teoria/ccp/#modo-pwm","title":"Modo PWM","text":"<p> Antes de nada, recordemos los dos elementos de una se\u00f1al (cuadrada) PWM. Primero, el periodo es el tiempo que transcurre entre dos flancos ascendentes/descendentes consecutivos de la se\u00f1al. Segundo, el tiempo de servicio (duty cycle) es el porcentaje de tiempo que la se\u00f1al est\u00e1 en alto respecto a un per\u00edodo. Eso es todo.</p> Diagrama de bloques del m\u00f3dulo CCP del PIC18F47Q10 <sup>1</sup> <p>Puedes saltearte la explicaci\u00f3n del c\u00f3mo funciona internamente el m\u00f3dulo CCP si quieres y continuar leyendo sobre los elementos de la se\u00f1al PWM. Empecemos viendo el bloque del modulo TMR2 (timer asociado por defecto al CPPx). Primero, podemos ver que TMR2 (de 8 bits) cuenta hasta que alcanza el valor de <code>PRx</code> (referencia al registro <code>TxPR</code>). Cuando esto sucede (han pasado <code>PRx</code>\\(+1\\) cuentas), TMR2 se reinicia a cero, manda una se\u00f1al al 10-bit Latch y activa el flip-flop SR. As\u00ed, el 10-bit Latch se actualiza con el valor que representa el registro <code>CCPRx</code> y la se\u00f1al PWM se mantiene en alto. Luego, cuando TMR2 concatenado a 2 bits generados por \\(F_OSC\\) (o el prescaler) es igual al valor del 10-bit Latch (han pasado <code>CCPRx</code> cuentas), se da reset al flip-flop SR, lo que hace que la se\u00f1al PWM se ponga en bajo. Finalmente, el ciclo se repite, generando una se\u00f1al PWM con un periodo definido por <code>PRx</code> y un duty cycle definido por <code>CCPRx</code>.</p>"},{"location":"teoria/ccp/#periodo-de-la-senal-pwm","title":"Periodo de la se\u00f1al PWM","text":"<p>El periodo de la se\u00f1al PWM est\u00e1 definido por la cuenta m\u00e1xima del temporizador TMR2/4/6 de 10 bits asociado al m\u00f3dulo CCPx. </p> <p>En el Q10, el timer se asocia al m\u00f3dulo CCPx mediante los bits <code>CxTSEL</code> del registro <code>CCPTMRS</code>. En el Q43, mediante los bits <code>CxTSEL</code> del registro <code>CCPTMRS0</code>.</p> CCPx Timer Selection bits <sup>2</sup> <sup>3</sup> CxTSEL[1:0] Timer Asociado 01 TMR2 10 TMR4 11 TMR6 <code>CCPTMRS</code> vs. <code>CCPTMRS0</code> <p>El Q10 comparte el registo <code>CCPTMRS</code> entre los m\u00f3dulos CCP1/2 y PWM3/4. En cambio, el Q43 usa el registro <code>CCPTMRS0</code> solo para los m\u00f3dulos CCP1/2/3. Esto se debe a que: - El Q43 tiene m\u00e1s m\u00f3dulos CCP - El Q43 tiene m\u00e1s m\u00f3dulos PWM, cada uno con su propio registro de selecci\u00f3n de timer. As\u00ed, un solo registro no es suficiente para configurar todos los m\u00f3dulos CCP y PWM del Q43, mientras que s\u00ed lo es para el Q10.</p> <p>Los timers TMR2/4/6 son de 8 bits, lo que significa que cuentan desde 0 hasta 255.  Para configurar la cuenta m\u00e1xima, se carga el byte m\u00e1s significativo del valor m\u00e1ximo deseado en el registro <code>TxPR</code> del m\u00f3dulo TMRx.  Por ejemplo, si se carga el valor \\(200\\), el timer contar\u00e1 desde \\(0\\) hasta \\(200\\) antes de reiniciarse, lo que define el periodo de la se\u00f1al PWM.  En ese tiempo, se realizan \\(200+1=201\\) cuentas.  De esta forma, el periodo de la se\u00f1al PWM se puede calcular con la siguiente f\u00f3rmula:</p> \\[T_{PWM} = (TxPR + 1) \\times T_{CLK\\ INPUT} \\times Prescaler\\] \u00bfY el PostScaler? <p>El PostScaler del TMRx no afecta el periodo de la se\u00f1al PWM, ya que solo influye en la generaci\u00f3n de interrupciones, no en el conteo del timer.</p> <p>Pero, el modo PWM solo funciona correctamente cuando se usa \\(\\frac{F_{osc}}{4}\\) como fuente de reloj para el timer. Por esto, la f\u00f3rmula del periodo de la se\u00f1al PWM se convierte en<sup>4</sup>:</p> \\[T_{PWM} = \\frac{4 \\times (TxPR+1) \\times TMRx\\ Prescaler}{F_{osc}}\\] <p>Sin embargo, normalmente, la variable a hallar es <code>TxPR</code>, no el periodo de la se\u00f1al PWM:</p> \\[TxPR = \\frac{T_{PWM} \\times F_{osc}}{4 \\times TMRx\\ Prescaler} - 1\\]"},{"location":"teoria/ccp/#duty-cycle-de-la-senal-pwm","title":"Duty cycle de la se\u00f1al PWM","text":"<p> El tiempo en que la se\u00f1al PWM est\u00e1 activa se define por el valor que representa el registro <code>CCPRx</code>, conformado por <code>CCPRxH</code> y <code>CCPRxL</code>.  Adem\u00e1s, el bit <code>FMT</code> del registro <code>CCPxCON</code> define si el 10-bit Duty Cycle toma los 10 bits m\u00e1s significativos (<code>FMT = 1</code>) o los 10 bits menos significativos (<code>FMT = 0</code>) del registro <code>CCPRxH:L</code>.</p> <p>Por lo tanto, la duraci\u00f3n en activo de la se\u00f1al PWM es:</p> \\[T_{ON} = CCPRx\\text{ value}\\times \\frac{T_{\\text{CLK INPUT}}\\times TMRx\\text{ PreScaler}}{4}\\] <p>En concordancia con lo explicado sobre el bit <code>FMT</code>, <code>CCPRx value = CCPRxH[1:0]:CCPRxL</code> para <code>FMT = 0</code> y <code>CCPRx value = CCPRxH:CCPRxL[7:6]</code> para <code>FMT = 1</code>.  Adem\u00e1s, para el caso de que se use \\(\\frac{F_{osc}}{4}\\) como fuente de reloj para el timer, la duraci\u00f3n en activo de la se\u00f1al PWM ser\u00e1<sup>5</sup>:</p> \\[T_{ON} = CCPRx\\text{ value}\\times \\frac{TMRx\\text{ PreScaler}}{F_{osc}}\\] <p>Pero, normalmente, sabes el tiempo en activo que quieres generar. As\u00ed que, puedes despejar el valor de <code>CCPRx</code>:</p> \\[CCPRx\\text{ value} = \\frac{T_{ON} \\times F_{osc}}{TMRx\\text{ PreScaler}}\\]"},{"location":"teoria/ccp/#pasos-para-configurar-el-modo-pwm-forma-segura","title":"Pasos para configurar el modo PWM: Forma segura","text":"<p>Como gu\u00eda pr\u00e1ctica, Microchip recomienda seguir los siguientes pasos para generar una se\u00f1al PWM como salida en un pin<sup>6</sup>:</p> <ol> <li> <p>Selecciona el timer a usar (TMR2/4/6) usando el registro <code>CCPTMRS</code>.</p> Ejemplo: Selecci\u00f3n del timer asociado al CCPx <p>Para el Q10: Si quieres usar el TMR2 en el <code>CCP1</code>:</p> <p><pre><code>CCPTMRSbits.C1TSEL = 1; // CCP1 -&gt; TMR2\n</code></pre> <pre><code>bsf CCPTMRS, 0, a       ; CCP1 -&gt; TMR2. C1TSEL[1:0] = 01\n</code></pre></p> <p>Para el Q43: Si quieres usar el TMR2 en el <code>CCP1</code>:</p> <p><pre><code>CCPTMRS0bits.C1TSEL = 1; // CCP1 -&gt; TMR2\n</code></pre> <pre><code>movlb 3h               ; Banco 3\nbsf CCPTMRS0, 0, a     ; CCP1 -&gt; TMR2. C1TSEL[1:0] = 01\n</code></pre></p> </li> <li> <p>Asigna el CCPn al puerto Rxy usando el registro RxyPPS. Los puertos destino dependen del \u00b5C. Tabla para el Q10:    </p> <p>PPS output selection codes for CCP peripherals (Q10)<sup>7</sup></p> RxyPPS Fuente de salida del pin Rxy Puerto al que se puede dirigir la salida 0x05 CCP1 RB RC 0x06 CCP2 RB RC PPS en el Q43 <p>PPS output selection codes for CCP peripherals (Q43)<sup>8</sup></p> RxyPPS Fuente de salida del pin Rxy Puerto al que se puede dirigir la salida 0x15 CCP1 RC RF 0x16 CCP2 RF RF 0x17 CCP3 RB RD <p>Y, como medida de seguridad (pueden generarse \"pulsos basura\" mientras se configura el m\u00f3dulo), activa el pin como entrada (TRIS = 1).</p> Ejemplo: Configuraci\u00f3n del PPS <p>Para el Q10: Si quieres usar el CCP1, veo en la tabla qu\u00e9 puertos puedo usar (RB o RC)<sup>7</sup>. Usar\u00e9 el pin RC0: </p> <p><pre><code>RC0PPS = 0x05;          // RC0 -&gt; CCP1\nTRISCbits.TRISC0 = 1;   // RC0 como entrada\n</code></pre> Todos los registros RBxPPS y RCxPPS del Q10 est\u00e1n en el banco 14. <pre><code>movlb 0Eh               ; Banco 14\nmovlw 0x05\nmovwf RC0PPS, b         ; RC0 -&gt; CCP1\nbsf TRISC, 0, a         ; RC0 como entrada\n</code></pre></p> </li> <li> <p>Carga el registro <code>TxPR</code> con el valor que define el periodo de la se\u00f1al PWM.</p> Ejemplo: Configuraci\u00f3n del periodo PWM <p>Para el Q10: Si quieres generar una se\u00f1al PWM de 5 kHz (\\(T_{PWM} = 200\\ \\mu s\\)) usando el TMR2 (prescaler de 1:1, \\(\\text{clk input} = \\frac{F_{osc}}{4}\\)) y con \\(F_{osc} = 4\\ MHz\\), puedes usar la f\u00f3rmula para calcular el valor de <code>TxPR</code>:</p> \\[TxPR = \\frac{T_{PWM} \\times F_{osc}}{4 \\times TMRx\\text{ Prescaler}} - 1 = \\frac{200\\ \\mu s \\times 4\\ MHz}{4 \\times 1} - 1 = 199\\] <p><pre><code>T2PR = 199;             // Periodo de la se\u00f1al PWM = 200 us\n</code></pre> <pre><code>movlw 199\nmovwf T2PR, a           ; Periodo de la se\u00f1al PWM = 200 us\n</code></pre></p> <p>TxPR est\u00e1 asociado al timer TMR2/4/6, no al m\u00f3dulo CCPx</p> </li> <li> <p>Configura el registro <code>CCPxCON</code> en modo PWM (<code>MODE=11xx</code>) y la justificaci\u00f3n que desees (<code>FMT = 1</code> si es izquierda) para <code>CCPRx</code>.</p> <p>CCP Control Register (CCPxCON)<sup>9</sup></p> Bit 7 6 5 4 3:0 Campo EN \u2014 OUT FMT MODE[3:0] Permisos R/W \u2014 RO R/W R/W Reset 0 \u2014 x 0 0000 Configurar <code>CCPxCON.MODE</code> <p>Para el Q10: Al configurar el modo PWM, aprovecha en configurar el formato justificado a la izquierda (<code>FMT = 1</code>) si as\u00ed lo deseas:</p> <p><pre><code>CCP1CON = 0x9C;         // Modo PWM, justificado a la izquierda\n</code></pre> <pre><code>movlw 0x9C              ; 1001 1100\nmovwf CCP1CON, a        ; Modo PWM, justificado a la izquierda\n</code></pre> Obviamente, si deseas el formato justificado a la derecha, solo reemplaza el valor <code>0x9C</code> por <code>0x8C</code> (0000 1100).</p> </li> <li> <p>Configura el registro <code>CCPRxH</code> y <code>CCPRxL</code> con el valor que define el duty cycle de la se\u00f1al PWM.</p> Ejemplo: Configurar <code>CCPRx</code> <p>Para el Q10: Con las condiciones que se mencionaron en los anteriores ejemplos, si deseas un duty cycle del 25% (50 us), puedes usar la f\u00f3rmula para calcular el valor de <code>CCPRx</code>:</p> \\[CCPRx\\text{ value} = \\frac{T_{ON} \\times F_{osc}}{TMRx\\text{ prescaler}} = \\frac{50\\ \\mu s \\times 4\\ MHz}{1} = 200 = 0011\\ 0010\\ 00_{(2)}\\] <p>He separado el valor de <code>CCPRx</code> en 10 bits para mostrar c\u00f3mo se asignan los bits a <code>CCPRxH</code> y <code>CCPRxL</code> con el formato justificado a la izquierda (<code>FMT = 1</code>):</p> <p><pre><code>CCPR1H = 0x32;\nCCPR1L = 0;             // Duty cycle = 25%\n</code></pre> <pre><code>; Duty cycle = 25% (justificado a la izquierda)\nmovlw 0x32              \nmovwf CCPR1H, a\nclrf CCPR1L, a          ; CCPR1 = 200 = 0011 0010 00\n</code></pre> En cambio, si el formato es justificado a la derecha (<code>FMT = 0</code>), el valor de <code>CCPRx</code> seguir\u00eda siendo el mismo, pero interpretado como \\(200 = 00\\ 1100\\ 1000_{(2)}\\). O sea, <code>CCPRxH = 0</code> y <code>CCPRxL = 0xC8</code>.</p> </li> <li> <p>Terminar la configuraci\u00f3n del TMRx.</p> <ul> <li>Baja la bandera TMRxIF en el registro PIR4.</li> <li>Selecciona \\(F_{osc}/4\\) como fuente de reloj del TMRx asignando <code>TxCLKCON=1</code>.</li> </ul> <p>Peripheral Interrupt Request Register 4 (PIR4): TMR2/4/6<sup>10</sup></p> Bit 5 3 1 Campo TMR6IF TMR4IF TMR2IF Permisos R/W R/W R/W Reset 0 0 0 <ul> <li>Configura el PreScaler del TMRx en los bits <code>CKPS</code> del registro <code>TxCON</code>.</li> <li>Habilito el timer activando el bit <code>ON</code> del registro <code>TxCON</code>.</li> </ul> <p>Timerx Control Register (TxCON)<sup>11</sup></p> Bit 7 6:4 3:0 Campo ON CKPS[2:0] OUTPS[3:0] Permisos R/W/HC R/W R/W Reset 0 000 0000 Ejemplo: Configuraci\u00f3n del TMRx <p>Para el Q10: Sigo el ejemplo del uso del TMR2.</p> <p><pre><code>PIR4bits.TMR2IF = 0;    // Baja la bandera de interrupci\u00f3n del TMR2\nT2CLKCON = 1;           // Fuente de reloj = Fosc/4\nT2CON = 0x80;           // PreScaler 1:1, TMR2 habilitado\n</code></pre> <pre><code>movlb 0Eh               ; Banco 14\nbcf PIR4, 1, b          ; Baja la bandera de interrupci\u00f3n del TMR2\nbsf T2CLKCON,0, a       ; Fuente de reloj = Fosc/4. T2CLKCON.CS = 1\nbsf T2CON, 7, a         ; PreScaler 1:1, TMR2 habilitado\n</code></pre></p> </li> <li> <p>Habilita la salida PWM:</p> <ul> <li> <p>Espera a que la bandera TMR2IF del registro PIR4 se active.</p> </li> <li> <p>Activa la salida del pin CCPx limpiando el bit TRIS asociado.</p> </li> </ul> Ejemplo: Habilitar la salida PWM <p>Para el Q10: Siguiendo el ejemplo, hab\u00eda asociado el pin RC0 al CCP1. Entonces, uso un algoritmo de \"enclave\" para habilitar la salida PWM:  <pre><code>    flowchart TD\n    A{PIR4.TMR2IF == 1}\n    B[TRISC.TRISC0 = 0]\n\n    A -- No --&gt; A\n    A -- S\u00ed --&gt; B</code></pre>  De</p> <p><pre><code>while(!PIR4bits.TMR2IF);   // Espero a que se active la bandera de interrupci\u00f3n del TMR2\nTRISCbits.TRISC0 = 0;     // RC0 como salida\n</code></pre> <pre><code>movlb 0Eh               ; Banco 14\nbtfss PIR4, 1, b        ; Espero a que se active la bandera de interrupci\u00f3n \nbra $-2\nbcf TRISC, 0, a         ; RC0 como salida\n</code></pre></p> </li> </ol>"},{"location":"teoria/ccp/#pasos-para-configurar-el-modo-pwm-forma-rapida","title":"Pasos para configurar el modo PWM: Forma r\u00e1pida","text":"<p>Los pasos anteriormente expuestos son la forma larga, pero m\u00e1s segura, de configurar el modo PWM. Si no es importante evitar los \"pulsos basura\" durante la configuraci\u00f3n, puedes ignorar el paso 6 y 5.1, y configurar el pin como salida desde el principio.</p> Configuraci\u00f3n r\u00e1pida del modo PWM <p>Para el Q10: Modificar\u00e9 el ejemplo anterior para configurar el modo PWM de forma r\u00e1pida. Las suposiciones del reloj y los c\u00e1lculos para el periodo y duty cycle de la se\u00f1al PWM siguen siendo los mismos, as\u00ed que solo mostrar\u00e9 el c\u00f3digo de configuraci\u00f3n:</p> <pre><code>CCPTMRSbits.C1TSEL = 1; // CCP1 -&gt; TMR2\nRC0PPS = 0x05;          // RC0 -&gt; CCP1\nTRISCbits.TRISC0 = 0;   // RC0 como salida\nT2PR = 199;             // Periodo de la se\u00f1al PWM = 200 us\nCCP1CON = 0x9C;         // Modo PWM, justificado a la izquierda\nCCPR1H = 0x32;\nCCPR1L = 0;             // Duty cycle = 25%\nT2CLKCON = 1;           // Fuente de reloj = Fosc/4\nT2CON = 0x80;           // PreScaler 1:1, TMR2 habilitado\n</code></pre>"},{"location":"teoria/ccp/#proyectos","title":"Proyectos","text":"<p>Te dejo algunos proyectos relacionados con el m\u00f3dulo CCP en modo PWM para que puedas adjuntarlo a tu IA de confianza y ver c\u00f3mo se configura el m\u00f3dulo CCP en otros contextos.</p>"},{"location":"teoria/ccp/#referencias","title":"Referencias","text":"<ol> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 22.4.1, \"Standard PWM Operation\". Ver PDF (P\u00e1g. 351).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 22.6.4, \"CCPTMRS\". Ver PDF (P\u00e1g. 359).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2021). PIC18F27/47/57Q43 Microcontroller Data Sheet. Secci\u00f3n 29.1.1, \"CCPTMRS0\". Ver PDF (P\u00e1g. 463).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 22.4.4, \"PWM Period\". Ver PDF (P\u00e1g. 352).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 22.4.5, \"PWM Duty Cycle\". Ver PDF (P\u00e1g. 353).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 22.4.2, \"Setup for PWM Operation\". Ver PDF (P\u00e1g. 351).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 18.2, \"PPS Outputs\". Ver PDF (P\u00e1g. 287).\u00a0\u21a9\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2021). PIC18F27/47/57Q43 Microcontroller Data Sheet. Secci\u00f3n 21.3, \"PPS Outputs\". Ver PDF (P\u00e1g. 344).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 22.6.1, \"CCPxCON\". Ver PDF (P\u00e1g. 356).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.13.6, \"PIR4\". Ver PDF (P\u00e1g. 203).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 21.9.3, \"TxCON\". Ver PDF (P\u00e1g. 341).\u00a0\u21a9</p> </li> </ol>"},{"location":"teoria/interrupciones/","title":"Interrupciones","text":""},{"location":"teoria/interrupciones/#que-es-una-interrupcion","title":"\u00bfQu\u00e9 es una interrupci\u00f3n?","text":"<p>Las interrupciones suspenden temporalmente la ejecuci\u00f3n del \u03bcC del programa principal para atender un evento (externo o interno). Una vez atendido, se retoma la ejecuci\u00f3n normal mediante la instrucci\u00f3n <code>RETFIE</code>. As\u00ed, el evento disparador de la rutina se llama fuente de interrupci\u00f3n, el c\u00f3digo que se ejecuta para atenderla es la rutina de servicio de interrupci\u00f3n (ISR) y la direcci\u00f3n de memoria donde se encuentra la ISR es el vector de interrupci\u00f3n.</p>"},{"location":"teoria/interrupciones/#vectores-de-interrupcion","title":"Vectores de interrupci\u00f3n","text":"<p>El Q10 tiene 2 vectores de interrupci\u00f3n<sup>1</sup>: <code>0x0008</code> para interrupciones de alta prioridad y <code>0x0018</code> para las de baja prioridad. Es m\u00e1s, al desactivar las prioridades, todas las interrupciones van al vector de alta prioridad <code>0x0008</code>.</p> Vectores de interrupci\u00f3n en el Q43 <p>El Q43 utiliza un controlador de interrupciones vectorizado (VIC) con una tabla de vectores configurable a trav\u00e9s de <code>IVTBASE</code>, en lugar de los dos vectores fijos del Q10.</p>"},{"location":"teoria/interrupciones/#registro-de-control-de-interrupciones-intcon","title":"Registro de control de interrupciones (INTCON)","text":"<p>El registro <code>INTCON</code> es el registro principal de control de interrupciones del Q10<sup>2</sup>. Reside en el Access bank y controla la habilitaci\u00f3n global de interrupciones, el modo de prioridad y la selecci\u00f3n de flanco para las interrupciones externas.</p> Interrupt Control Register (INTCON)<sup>2</sup> Bit 7 6 5 2 1 0 Campo GIE/GIEH PEIE/GIEL IPEN INT2EDG INT1EDG INT0EDG Permisos R/W R/W R/W R/W R/W R/W Reset 0 0 0 1 1 1 <code>GIE/GIEH</code> <p>Habilitaci\u00f3n global de interrupciones. Su comportamiento depende del modo de prioridad:</p> <ul> <li>Si <code>IPEN = 1</code>: habilita las interrupciones de alta prioridad.</li> <li>Si <code>IPEN = 0</code>: habilita las interrupciones no perif\u00e9ricas. </li> </ul> <code>PEIE/GIEL</code> <p>Habilitaci\u00f3n de interrupciones perif\u00e9ricas / de baja prioridad:</p> <ul> <li>Si <code>IPEN = 1</code>: habilita todas las interrupciones de baja prioridad.</li> <li>Si <code>IPEN = 0</code>: habilita todas las interrupciones perif\u00e9ricas.</li> </ul> <p>No se puede activar si no est\u00e1 activado <code>GIE/GIEH</code>.</p> <code>IPEN</code> Habilitaci\u00f3n de prioridades de interrupci\u00f3n. <code>1</code> = prioridades habilitadas y configurables, como altas o bajas, en su registro de prioridad de interrupci\u00f3n <code>IPRx</code>.\u00b7 <code>0</code> = prioridades deshabilitadas y se ignoran los registros de prioridad <code>IPRx</code>. <code>INTxEDG</code> (x = 0, 1, 2) Selecci\u00f3n de flanco para la interrupci\u00f3n externa INTx. <code>1</code> = flanco ascendente \u00b7 <code>0</code> = flanco descendente."},{"location":"teoria/interrupciones/#fuentes-de-interrupcion","title":"Fuentes de interrupci\u00f3n","text":"<p>Cada fuente de interrupci\u00f3n del Q10 se gestiona mediante tres bits distribuidos en los registros <code>PIRx</code>, <code>PIEx</code> e <code>IPRx</code><sup>4</sup> <sup>5</sup> <sup>6</sup>:</p> <ul> <li><code>PIRx</code> \u2014 Peripheral Interrupt Request (bandera): se activa por hardware cuando ocurre el evento. Se debe limpiar por software en la ISR.</li> <li><code>PIEx</code> \u2014 Peripheral Interrupt Enable (habilitaci\u00f3n): habilita la interrupci\u00f3n individual de cada fuente.</li> <li><code>IPRx</code> \u2014 Interrupt Priority Register (prioridad): <code>1</code> = alta prioridad \u00b7 <code>0</code> = baja prioridad. Solo tiene efecto si <code>IPEN = 1</code>.</li> </ul> <p>Los tres registros siguen la misma estructura: el mismo n\u00famero de registro (<code>x</code>) y el mismo bit controlan la misma fuente de interrupci\u00f3n. Por ejemplo, <code>TMR0IF</code> (bandera), <code>TMR0IE</code> (habilitaci\u00f3n) y <code>TMR0IP</code> (prioridad) est\u00e1n todos en el bit 5 de <code>PIR0</code>, <code>PIE0</code> e <code>IPR0</code> respectivamente.</p>"},{"location":"teoria/interrupciones/#mapa-de-registros-de-interrupcion","title":"Mapa de registros de interrupci\u00f3n","text":"<p>La siguiente tabla resume todas las fuentes de interrupci\u00f3n perif\u00e9ricas del Q10 y los bits asociados en los registros <code>PIRx</code>/<code>PIEx</code>/<code>IPRx</code>. Todos estos registros est\u00e1n en el banco <code>0Eh</code><sup>7</sup>.</p> Resumen de registros de interrupci\u00f3n <sup>7</sup> #Reg Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 <code>0</code> \u2014 \u2014 TMR0 IOC \u2014 INT2 INT1 INT0 <code>1</code> OSCF CSW \u2014 \u2014 \u2014 \u2014 ADT AD <code>2</code> HLVD ZCD \u2014 \u2014 \u2014 \u2014 C2 C1 <code>3</code> RC2 TX2 RC1 TX1 BCL2 SSP2 BCL1 SSP1 <code>4</code> \u2014 \u2014 TMR6 TMR5 TMR4 TMR3 TMR2 TMR1 <code>5</code> CLC4 CLC3 CLC2 CLC1 \u2014 TMR5G TMR3G TMR1G <code>6</code> CLC8 CLC7 CLC6 CLC5 \u2014 \u2014 CCP2 CCP1 <code>7</code> SCAN CRC \u2014 NVM \u2014 \u2014 \u2014 CWG1 \u00bfC\u00f3mo leer esta tabla? <p>Para encontrar los bits asociados a una fuente de interrupci\u00f3n, busca el sufijo del perif\u00e9rico. Por ejemplo, para el TMR0:</p> <ul> <li>Bandera: <code>TMR0IF</code> \u2192 <code>PIR0</code>, bit 5 (direcci\u00f3n <code>0x0EC5</code>).</li> <li>Habilitaci\u00f3n: <code>TMR0IE</code> \u2192 <code>PIE0</code>, bit 5 (direcci\u00f3n <code>0x0EBD</code>).</li> <li>Prioridad: <code>TMR0IP</code> \u2192 <code>IPR0</code>, bit 5 (direcci\u00f3n <code>0x0EB5</code>).</li> </ul> <p>Los tres registros siempre comparten el mismo n\u00famero (<code>PIR0</code>/<code>PIE0</code>/<code>IPR0</code>) y el mismo bit (5) para la misma fuente.</p>"},{"location":"teoria/interrupciones/#pasos-para-configurar-interrupciones-con-prioridad","title":"Pasos para configurar interrupciones con prioridad","text":"<p>Normalmente, se usan las interrupciones con prioridad en el Q10:</p> <ol> <li> <p>Configurar el perif\u00e9rico que generar\u00e1 la interrupci\u00f3n (TMR0, CCP, EUSART, etc.).</p> </li> <li> <p>Habilitar las interrupciones con prioridad en <code>INTCON</code>.</p> Ejemplo: Habilitar interrupciones globales <p>Con prioridades habilitadas (<code>IPEN = 1</code>), para habilitar alta y baja prioridad:</p> <p><pre><code>INTCONbits.IPEN = 1;    // Habilitar prioridades\nINTCONbits.GIEH = 1;    // Habilitar interrupciones de alta prioridad\nINTCONbits.GIEL = 1;    // Habilitar interrupciones de baja prioridad\n</code></pre> <pre><code>setf INTCON, a        ; IPEN = 1, GIE/GIEH = 1, PEIE/GIEL = 1\n</code></pre></p> <p>Sin prioridades (<code>IPEN = 0</code>):</p> <p><pre><code>INTCONbits.GIE = 1;     // Habilitar interrupciones globales\nINTCONbits.PEIE = 1;    // Habilitar interrupciones perif\u00e9ricas\n</code></pre> <pre><code>bsf INTCON, 7, a        ; GIE = 1\nbsf INTCON, 6, a        ; PEIE = 1\n</code></pre></p> </li> <li> <p>Bajar la bandera de interrupci\u00f3n correspondiente en <code>PIRx</code>.</p> Ejemplo: Bajar bandera del TMR0 <p><pre><code>PIR0bits.TMR0IF = 0;\n</code></pre> <pre><code>movlb 0Eh\nbcf PIR0, 5, b          ; TMR0IF = 0\n</code></pre></p> </li> <li> <p>Habilitar la interrupci\u00f3n individual en <code>PIEx</code>.</p> Ejemplo: Habilitar interrupci\u00f3n del TMR0 <p><pre><code>PIE0bits.TMR0IE = 1;\n</code></pre> <pre><code>bsf PIE0, 5, b          ; TMR0IE = 1\n</code></pre></p> </li> <li> <p>Configurar la prioridad en <code>IPRx</code>.</p> Ejemplo: Alta prioridad para TMR0 <p><pre><code>IPR0bits.TMR0IP = 1;    // Alta prioridad\n</code></pre> <pre><code>bsf IPR0, 5, b          ; TMR0IP = 1 (alta prioridad)\n</code></pre></p> </li> <li> <p>En la ISR, limpiar la bandera <code>PIRx</code> correspondiente antes de salir con <code>RETFIE</code>.</p> <p>Limpiar la bandera en la ISR</p> <p>Si no se limpia la bandera de interrupci\u00f3n (<code>PIRx</code>) dentro de la ISR, la interrupci\u00f3n se disparar\u00e1 continuamente al salir de la rutina con <code>RETFIE</code>.</p> </li> </ol>"},{"location":"teoria/interrupciones/#referencias","title":"Referencias","text":"<ol> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.2, \"Interrupt Priority\". Ver PDF (P\u00e1g. 192).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.13.1, \"INTCON\". Ver PDF (P\u00e1g. 195).\u00a0\u21a9\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.2, \"Interrupt Priority\". Ver PDF (P\u00e1g. 192).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.5, \"PIR Registers\". Ver PDF (P\u00e1g. 195).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.6, \"PIE Registers\". Ver PDF (P\u00e1g. 195).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.7, \"IPR Registers\". Ver PDF (P\u00e1g. 195).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.12, \"Register Summary - Interrupt Control\". Ver PDF (P\u00e1g. 197).\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"teoria/introduccion/","title":"Introducci\u00f3n y Entorno de Trabajo","text":"","tags":["introducci\u00f3n","MPLAB","PIC"]},{"location":"teoria/introduccion/#que-es-un-microcontrolador","title":"\u00bfQu\u00e9 es un microcontrolador?","text":"<p>La definici\u00f3n cl\u00e1sica, que tal vez la habr\u00e1s escuchado (y olvidado) antes, es que un microcontrolador (\u00b5C) es un computador programable peque\u00f1o que se presenta en un solo circuito integrado. Adem\u00e1s, se compone por un procesador, memoria y perif\u00e9ricos.</p> <p>Muy probablemente ya haz tratado con el microcontrolador ATmega328P (usado en el Arduino Uno) en cursos anteriores, pero en este curso nos enfocaremos en el PIC18F57Q43 (en adelante, 'Q43') y el PIC18F47Q10 (en adelante, 'Q10'). Se usa el Q10 porque puede ser simulado en Proteus, pero el Q43 posee m\u00e1s perif\u00e9ricos y caracter\u00edsticas avanzadas.</p> <p>De la definici\u00f3n, se resalta que un \u00b5C:</p> <ul> <li>Se programa. O sea, que al energizarlo, no har\u00e1 nada si no le haz cargado un programa previamente. Por ejemplo, el Q10 y Q53 se programan mediante el PicKit 5 o el Curiosity Nano respectivo de cada uno.</li> <li>Es peque\u00f1o. Por ende, es barato (~0,5-3 USD los de 8-bits) y con recursos de procesamiento y almacenamiento limitados.</li> <li>Tiene un procesador. Comercialmente se encuentran microcontroladores de 8, 16 y 32 bits. Por ejemplo, el Q10, Q53 y ATmega328P son de 8 bits, mientras que el ESP32 es de 32 bits. La cantida de bits se refiere a la cantidad de bits que el procesador puede manejar en una sola operaci\u00f3n. O sea, es el ancho de los registros, buses de datos y direcciones.</li> <li>Tiene memoria. Los \u00b5C cuentan con diferentes tipos de memoria: no vol\u00e1til (ej: Flash y EEPROM) para el programa y datos persistentes, y vol\u00e1til (ej: SRAM) para datos temporales.</li> <li>Tiene perif\u00e9ricos. Son m\u00f3dulos integrados que permiten al \u00b5C interactuar con el mundo exterior o realizar funciones espec\u00edficas sin necesidad de hardware adicional. Todos los \u00b5C tienen puertos de E/S. En adicion, el Q43 y Q10 tienen modulos temporizadores, ADC, UART, etc.</li> </ul> <p>En fin, aclaro que en la UPC se abandon\u00f3 el Q53 por el Q10 y que, a pesar de que el Q10 se puede simular, debes comprar el Curiosity Nano del Q10 si planeas aprobar el curso (o el del Q43, si te lo permiten). Adicionalmente, te recomiendo que descargues el datasheet del Curiosity Nano que compres y el de su microcontrolador para que lo tengas a la mano.</p>","tags":["introducci\u00f3n","MPLAB","PIC"]},{"location":"teoria/introduccion/#familia-pic18f-vision-general","title":"Familia PIC18F \u2014 Visi\u00f3n general","text":"<p>La familia PIC18F de Microchip Technology es la serie tope de gamma de sus microcontroladores PIC de 8 bits. Estos dispositivos son conocidos por su arquitectura RISC, eficiencia energ\u00e9tica y amplia gama de perif\u00e9ricos integrados. Como su nombre advierte, el Q10 y Q43 pertenecen a esta serie.</p>","tags":["introducci\u00f3n","MPLAB","PIC"]},{"location":"teoria/introduccion/#entorno-de-desarrollo","title":"Entorno de desarrollo","text":"<p>Para desarrollar software para los PIC, se suele usar MPLAB X IDE, el entorno de desarrollo integrado oficial de Microchip. Aun as\u00ed, tambi\u00e9n se puede usar VSCode con la extensi\u00f3n MPLAB. Para ello, recomiendo instalarlo en un perfil de VSCode que no sea el default por el peso de la extensi\u00f3n. Adem\u00e1s, es mejor si solo usas un IDE para evitar el secuestro del programador de tu Curiosity Nano.</p>","tags":["introducci\u00f3n","MPLAB","PIC"]},{"location":"teoria/introduccion/#instalar-mplab-x-ide","title":"Instalar MPLAB X IDE","text":"<p>Te recomiendo que uses Windows. Eres ingenier/a, no productor/ra musical. De este modo, solo debes descargar el instalador, dar siguiente, siguiente, siguiente y listo.</p> <p>No intales todos los compiladores</p> <p>Solo necesitas el XC8, que incluye el PIC-AS (assembler). No es necesario instalar el XC16 ni el XC32.</p>","tags":["introducci\u00f3n","MPLAB","PIC"]},{"location":"teoria/introduccion/#crear-proyectos-en-mplab-x","title":"Crear proyectos en MPLAB X","text":"<p>Para crear un nuevo proyecto, haz clic en \"File\" \u2192 \"New Project\" o en la esquina superior izquierda, en el \u00edcono de \"New Project\". Te saldr\u00e1 la siguiente ventana:</p> Paso 1: Selecci\u00f3n del tipo de proyecto <p>Aqu\u00ed, siempre damos \"Siguiente\". Luego, te pedir\u00e1n elegir tu dispositivo (PIC18F57Q43 o PIC18F47Q10) y la herramienta. Si no quieres escribir el nombre completo, puedes conectar de antemano tu Curiosity Nano y se seleccionar\u00e1n ambas autom\u00e1ticamente. De no contar con el hardware, puedes escribir el nombre del PIC en el buscador y seleccionar \"Simulator\" como herramienta. Despu\u00e9s, dale click en \"Siguiente\".</p> Paso 2: Selecci\u00f3n del dispositivo y herramienta de programaci\u00f3n <p>Lo que sigue es elegir el compilador. En la primera parte del curso usaremos el lenguaje ensamblador (pic-as), pero luego pasaremos a C (xc8). Elige el que corresponda y dale \"Siguiente\".</p> Paso 3: Selecci\u00f3n del compilador <p>Finalmente, elige un nombre para tu proyecto y la ubicaci\u00f3n donde se guardar\u00e1. Puede que parezca el paso m\u00e1s trivial, pero si eliges una ubicaci\u00f3n con espacios o caracteres especiales, podr\u00edas tener problemas m\u00e1s adelante. De preferencia, usa la ruta por defecto con un nombre de proyecto con nomenclatura CamelCase o snake_case. Luego, deselecciona \"Abrir Open MCC al finalizar\", haz clic en \"Finalizar\" y listo, ya tienes tu proyecto creado.</p> Paso 4: Nombre y ubicaci\u00f3n del proyecto <p>Por si vas a crear el proyecto en MPLAB X IDE, pero editar los archivos en VSCode, te recomiendo que cambies el encoding UTF-8, ya que por defecto est\u00e1 seleccionado el ISO-8859-1, lo que puede generar problemas con las tildes y e\u00f1es.</p>","tags":["introducci\u00f3n","MPLAB","PIC"]},{"location":"teoria/introduccion/#instalar-proteus","title":"Instalar Proteus","text":"<p>Proteus es un software de pago (con opci\u00f3n de prueba que no te permite guardar archivos). Y, para que simule el PIC18F57Q10, necesitas la versi\u00f3n paga.  Si vendes un ri\u00f1\u00f3n o haces magia negra para conseguirlo, no es mi responsabilidad. Pero, si quieres aprobar el curso... Instalalo.</p>","tags":["introducci\u00f3n","MPLAB","PIC"]},{"location":"teoria/introduccion/#etapas-de-desarrollo","title":"Etapas de desarrollo","text":"<p>Cuando desarrollas un programa para un \u00b5C, lo que se escribe en su memoria de programa no es el texto que t\u00fa ves en el editor de c\u00f3digo. En realidad, el \u00b5C solo entiende instrucciones en binario. Por esto, tu c\u00f3digo fuente debe pasar por estas 3 etapas antes de ser grabado en tu \u00b5C.</p>","tags":["introducci\u00f3n","MPLAB","PIC"]},{"location":"teoria/introduccion/#build-time","title":"Build Time","text":"<p>Aqu\u00ed es donde act\u00faan las directivas (instrucciones para el software ensamblador pic-as y el Linker xc8-cc). Esto ocurre en tu PC cuando compilas.</p> <ul> <li>Assembly Time (Traducci\u00f3n):</li> </ul> <p>Por ejemplo, <code>EQU</code> o <code>#define</code>, son reemplazos de texto o asignaci\u00f3n de valores constantes. Por esto , en <code>LED_PIN EQU 5</code>, el ensamblador busca donde dice LED_PIN y pone un 5.    Otro ejemplo es <code>#include</code>, que copia y pega texto de otro archivo.</p> <ul> <li>Link Time (Organizaci\u00f3n de Memoria):</li> </ul> <p>Por ejemplo, <code>PSECT</code> (o el antiguo <code>ORG</code>). Le dice al Linker: \"Reserva este espacio en la memoria RAM\" o \"Coloca las siguientes instrucciones a partir de la direcci\u00f3n <code>0x0020</code> de la Flash\".   Otro ejemplo es <code>GLOBAL</code> y <code>EXTRN</code>, que le dicen al Linker c\u00f3mo conectar variables entre diferentes archivos .s.</p>","tags":["introducci\u00f3n","MPLAB","PIC"]},{"location":"teoria/introduccion/#programming-time","title":"Programming Time","text":"<p>Este es un tiempo intermedio exclusivo de los microcontroladores. Ocurre cuando el programador (PICkit) quema el hex en el chip. Aqu\u00ed, se graba la memoria de programa y los bits de configuraci\u00f3n (fuses) del PIC.</p>","tags":["introducci\u00f3n","MPLAB","PIC"]},{"location":"teoria/introduccion/#runtime","title":"Runtime","text":"<p>Aqu\u00ed es cuando reci\u00e9n se ejecutan las instrucciones. Esto ocurre cuando se energiza el \u00b5C. El \u00b5C lee la instrucci\u00f3n de la memoria de programa que apunta el contador de programa (PC), iniciando desde la direcci\u00f3n <code>00 0000h</code>, las decodifica y ejecuta.</p>","tags":["introducci\u00f3n","MPLAB","PIC"]},{"location":"teoria/temporizadores/","title":"Temporizadores","text":"<p>Los Q10 y Q43 cuentan con tres tipos de m\u00f3dulos de temporizaci\u00f3n:</p> M\u00f3dulo Resoluci\u00f3n Uso t\u00edpico TMR0 8 o 16 bits General TMR1 16 bits Tiempo preciso, CCP TMR2 8 bits PWM, ADC <p>A continuaci\u00f3n se detalla el funcionamiento del m\u00f3dulo TMR0. Se mencionar\u00e1n el TMR1/3/5 y TMR2/4/6 en los m\u00f3dulos que usan esos temporizadores.</p>"},{"location":"teoria/temporizadores/#timer-0-tmr0","title":"Timer 0 (TMR0)","text":"Diagrama de bloques del m\u00f3dulo TMR0 del PIC18F47Q10 <sup>1</sup> <p>El m\u00f3dulo TMR0 es un temporizador/contador de 8 o 16 bits que incrementa su valor en cada flanco positivo de la fuente de reloj. Cuando llega al valor m\u00e1ximo ocurre un overflow (16 bits) o un match (8 bits); en ambos casos, se reinicia la cuenta. Si un evento de overflow/match ocurre la cantidad de veces configurada en el postscaler, se levanta la bandera <code>TMR0IF</code> del registro <code>PIR0</code><sup>6</sup> y la se\u00f1al <code>T0_out</code> se alterna. La cuenta actual est\u00e1 en los registros <code>TMR0L</code> y <code>TMR0H</code> (en 8 bits solo <code>TMR0L</code>).</p> TMR0 en el Q43 <p>En el Q43, la bandera de interrupci\u00f3n <code>TMR0IF</code> se encuentra en el bit 7 del registro <code>PIR3</code> (banco 4) en lugar de <code>PIR0</code>. An\u00e1logamente, <code>TMR0IE</code> est\u00e1 en <code>PIE3</code> y <code>TMR0IP</code> en <code>IPR3</code>.</p> <p>De este modo, la duraci\u00f3n total de un ciclo del temporizador se puede calcular con:</p> \\[ \\text{Duracion} = \\frac{\\text{PreScaler} \\times \\text{Num. Cuentas} \\times \\text{PostScaler}}{F_{\\text{TMR0}}} \\] <p>Pero, lo que normalmente se calcula es el valor de <code>TMR0L</code> y <code>TMR0H</code> para obtener la cantidad de cuentas deseada. Esto se calcula de forma diferente para  cada modo (8 o 16 bits), como se detalla a continuaci\u00f3n.</p>"},{"location":"teoria/temporizadores/#modo-8-bits","title":"Modo 8 bits","text":"Diagrama de bloque del TMR0 en modo 8 bits <p>Como se aprecia en su diagrama de bloques, el <code>TMR0L</code> es comparado con <code>TMR0H</code> en cada cuenta. Si son iguales, se genera un match y el <code>TMR0L</code> se reinicia a 0. Por lo tanto, en modo de 8 bits, se puede contar hasta 254 porque al llegar a 255 se genera el match y se reinicia a 0. En este sentido, se afirma que:</p> \\[ \\text{Num. Cuentas} \\leq 255 \\land \\mathtt{TMR0H} = \\text{Num. Cuentas} \\] \\[ \\mathtt{TMR0H} = \\frac {\\text{Duracion} \\times F_{\\text{T0CS}}} {\\text{PreScaler} \\times \\text{PostScaler}} \\leq 255 \\] Ejemplo <p>Si se escribe <code>100</code> en <code>TMR0H</code>, el <code>TMR0L</code> contar\u00e1 desde 0 hasta 99 (100 cuentas) y luego ocurrir\u00e1 el match.</p>"},{"location":"teoria/temporizadores/#modo-16-bits","title":"Modo 16 bits","text":"Diagrama de bloque del TMR0 en modo 16 bits <p>Como se ve en el diagrama de bloques, la cuenta inicia desde lo escrito en <code>TMR0H:TMR0L</code> y termina en <code>FFFF</code> (65 535).  En este modo, para contar una cantidad espec\u00edfica de tiempo, se puede precargar un valor inicial en <code>TMR0H:TMR0L</code>.</p> \\[ \\text{Num. Cuentas} \\leq 65536 \\land \\text{Num. Cuentas} = 65536 - \\mathtt{TMR0H:L} \\] \\[ \\mathtt{TMR0H:L} = 65536 - \\frac {\\text{Duracion} \\times F_{\\text{T0CS}}} {\\text{PreScaler} \\times \\text{PostScaler}} \\geq 0\\] <p>Orden de lectura / escritura</p> <ul> <li>Leer: primero <code>TMR0L</code>, luego <code>TMR0H</code>.</li> <li>Escribir: primero <code>TMR0H</code>, luego <code>TMR0L</code>.</li> </ul>"},{"location":"teoria/temporizadores/#pasos-para-configurar-el-tmr0","title":"Pasos para configurar el TMR0","text":"<p>Como gu\u00eda pr\u00e1ctica, se detallan los pasos necesarios para configurar el m\u00f3dulo TMR0:</p> <ol> <li> <p>Configurar <code>T0CON1</code>: seleccionar la fuente de reloj (<code>T0CS</code>), sincron\u00eda (<code>T0ASYNC</code>) y prescaler (<code>T0CKPS</code>).</p> <p>Timer0 Control Register 1 (T0CON1)<sup>3</sup></p> Bit 7:5 4 3:0 Campo T0CS[2:0] T0ASYNC T0CKPS[3:0] Permisos R/W R/W R/W Reset 000 0 0000 <p>Fuentes de reloj del TMR0 (T0CS)<sup>4</sup></p> T0CS[2:0] Fuente 000 T0CKIPPS 001 \\(\\overline{\\text{T0CKIPPS}}\\) 010 Fosc/4 011 HFINTOSC 100 LFINTOSC 101 MFINTOSC 500 kHz 110 SOSC 111 CLC1_OUT <p><code>T0ASYNC = 1</code> si la fuente es as\u00edncrona con el reloj del sistema.</p> <p><code>T0CKPS[3:0]</code> representa el prescaler de \\(2^{\\text{T0CKPS}}\\).</p> Ejemplo: Configuraci\u00f3n de T0CON1 <p>Para el Q10: Si quieres usar \\(F_{osc}/4\\) como fuente de reloj, modo s\u00edncrono y prescaler de 1:16 (\\(2^4\\)):</p> <p><pre><code>T0CON1 = 0x24;         // Fosc/4, s\u00edncrono, prescaler 1:16\n</code></pre> <pre><code>movlw 0x24              ; 0010 0100\nmovwf T0CON1, a         ; Fosc/4, s\u00edncrono, prescaler 1:16\n</code></pre></p> </li> <li> <p>Configurar <code>T0CON0</code>: seleccionar el modo (<code>T016BIT</code>) y el postscaler (<code>T0OUTPS</code>). No habilitar a\u00fan el timer (<code>T0EN = 0</code>).</p> <p>Timer0 Control Register 0 (T0CON0)<sup>2</sup></p> Bit 7 6 5 4 3:0 Campo T0EN \u2014 T0OUT T016BIT T0OUTPS[3:0] Permisos R/W \u2014 RO R/W R/W Reset 0 \u2014 0 0 0000 <p><code>T0EN</code> habilita el timer.  Y <code>T016BIT</code> habilita el modo de 16 bits. <code>T0OUT</code> es la salida del temporizador que se alterna al ocurrir la interrupci\u00f3n (solo lectura).</p> <p>Los bits <code>T0OUTPS[3:0]</code> representan el postscaler de <code>1:T0OUTPS+1</code>.</p> Ejemplo: Configuraci\u00f3n de T0CON0 <p>Para el Q10: Si quieres modo 8 bits, sin postscaler. Sin habilitar a\u00fan el timer (<code>T0EN = 0</code>):</p> <p><pre><code>T0CON0 = 0x00;         // 8 bits, postscaler 1:1, deshabilitado\n</code></pre> <pre><code>clrf T0CON0, a          ; 8 bits, postscaler 1:1, deshabilitado\n</code></pre></p> </li> <li> <p>Cargar la cuenta <code>TMR0</code> del timer:</p> <ul> <li>Escribir el valor calculado para <code>TMR0H</code> seg\u00fan el modo (8 o 16 bits).</li> <li>Si el modo es 16 bits, escribir el valor calculado para <code>TMR0L</code>.</li> </ul> Ejemplo: Carga del timer (8 bits) <p>Para el Q10: Con la configuraci\u00f3n de los ejemplos anteriores (modo 8 bits, sin postscaler, prescaler de 1:16 y reloj \\(\\frac{F_{\\text{osc}}}{4} = 1MHz\\)), si quieres configurar la duraci\u00f3n m\u00e1xima:</p> \\[ \\text{Duracion} = \\frac{1}{F_{\\text{T0CS}}} \\times \\text{PreScaler} \\times \\mathtt{TMR0H} \\times \\text{PostScaler}  = \\frac {16 \\times 255 \\times 1}{1MHz} = 4.08\\mu s  \\] <p><pre><code>TMR0H = 255;           // Cuenta m\u00e1xima = 255 (TMR0L: 0 \u2192 255)\n</code></pre> <pre><code>setf TMR0H, a          ; Cuenta m\u00e1xima = 255 (TMR0L: 0 \u2192 255)\n</code></pre></p> </li> <li> <p>(Opcional) Interrupci\u00f3n: Configurar los registros de interrupci\u00f3n del TMR0.</p> <ul> <li>Bajar la bandera <code>TMR0IF</code> del registro <code>PIR0</code>.</li> <li>Habilitar la interrupci\u00f3n <code>TMR0IE</code> del registro <code>PIE0</code>.</li> <li>Configurar la prioridad <code>TMR0IP</code> del registro <code>IPR0</code> (<code>1</code> = alta prioridad). En todos los casos, se hace referencia al bit 5 de cada registro.</li> </ul> Ejemplo: Configuraci\u00f3n de interrupci\u00f3n <p>Para el Q10: Habilitar la interrupci\u00f3n del TMR0 con alta prioridad:</p> <p><pre><code>PIR0bits.TMR0IF = 0;    // Bajar bandera de interrupci\u00f3n\nPIE0bits.TMR0IE = 1;    // Habilitar interrupci\u00f3n del TMR0\nIPR0bits.TMR0IP = 1;    // Alta prioridad\n</code></pre> <pre><code>movlb 0Eh               ; Banco 0Eh\nbcf PIR0, 5, b          ; Bajar bandera de interrupci\u00f3n\nbsf PIE0, 5, b          ; Habilitar interrupci\u00f3n del TMR0\nbsf IPR0, 5, b          ; Alta prioridad\n</code></pre></p> Interrupci\u00f3n del TMR0 en el Q43 <p>En el Q43, los bits <code>TMR0IF</code>, <code>TMR0IE</code> y <code>TMR0IP</code> se encuentran en los registros <code>PIR3</code> (bit 7), <code>PIE3</code> (bit 7) e <code>IPR3</code> (bit 7) respectivamente.</p> </li> <li> <p>(Opcional) Salida PPS: Escribir en <code>RxyPPS</code> el valor <code>0x13</code> para redirigir <code>T0_out</code> a un pin<sup>9</sup>. Solo disponible en puertos RB y RC. Divide \u00f72 la frecuencia de <code>T0_out</code>.</p> Ejemplo: Configuraci\u00f3n PPS <p>Para el Q10: Redirigir <code>T0_out</code> al pin RC0:</p> <p><pre><code>RC0PPS = 0x13;          // RC0 -&gt; T0_out\nTRISCbits.TRISC0 = 0;   // RC0 como salida\n</code></pre> Todos los registros RBxPPS y RCxPPS del Q10 est\u00e1n en el banco <code>0Eh</code>. <pre><code>movlb 0Eh               ; Banco 0Eh\nmovlw 0x13\nmovwf RC0PPS, b         ; RC0 -&gt; T0_out\nbcf TRISC, 0, a         ; RC0 como salida\n</code></pre></p> PPS del TMR0 en el Q43 <p>En el Q43, el c\u00f3digo PPS para <code>T0_out</code> es <code>0x39</code> y solo est\u00e1 disponible en puertos RC y RF.</p> </li> <li> <p>Habilitar el timer: activar el bit <code>T0EN</code> del registro <code>T0CON0</code>.</p> Ejemplo: Habilitar el TMR0 <p><pre><code>T0CON0bits.T0EN = 1;    // Habilitar TMR0\n</code></pre> <pre><code>bsf T0CON0, 7, a        ; Habilitar TMR0 (T0EN = 1)\n</code></pre></p> </li> </ol>"},{"location":"teoria/temporizadores/#referencias","title":"Referencias","text":"<ol> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 19, \"TMR0 - Timer0 Module\". Ver PDF (P\u00e1g. 295).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 19.6.1, \"T0CON0\". Ver PDF (P\u00e1g. 300).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 19.6.2, \"T0CON1\". Ver PDF (P\u00e1g. 301).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 19.2.1, \"Clock Source Selection\". Ver PDF (P\u00e1g. 296).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 19.6.3, \"TMR0H\". Ver PDF (P\u00e1g. 302).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.13.2, \"PIR0\". Ver PDF (P\u00e1g. 199).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.13.10, \"PIE0\". Ver PDF (P\u00e1g. 207).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 15.13.18, \"IPR0\". Ver PDF (P\u00e1g. 215).\u00a0\u21a9</p> </li> <li> <p>Microchip Technology Inc. (2020). PIC18F27/47Q10 Microcontroller Data Sheet. Secci\u00f3n 18.2, \"PPS Outputs\". Ver PDF (P\u00e1g. 287).\u00a0\u21a9</p> </li> </ol>"}]}